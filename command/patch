#! /bin/bash
#
# patch

patch_main() {
  # delegate arguments to the proper patch function
  # globals:
  #   none
  # arguments:
  #   $1: name of the patch function excluding the preceeding "patch_"
  # returns:
  #   none
  if ! declare -f -F "patch_${1}" > /dev/null; then
    patch_usage
    exit 1
  fi
  patch_${1} "${@:2}"
}

patch_finish() {
  # merge completed patch branch into release and master
  # globals:
  #   none
  # arguments:
  #   $1: name of the patch branch to finish
  # returns: 
  #   none
  if [[ $# -ne 1 ]]; then
    patch_usage
    exit 1
  fi
  local branch="patch/${1}"
  local message="finish ${branch}"

  git auto test run || exit 1

  # merge patch into release
  git checkout release
  git merge --no-ff "${branch}" -m "${message}"
  git auto version bump minor "${message}"

  # merge release into master
  git checkout master
  git merge --no-ff "${branch}" -m "${message}"
}

patch_publish() {
  # TODO(mraxilus): implement patch publishing
  echo "patch_publish unimplemented"
}

patch_start() {
  # create new patch branch based off of head of release
  # globals:
  #   none
  # arguments:
  #   $1: name of patch branch to create
  # returns: 
  #   none
  if [[ $# -ne 1 ]]; then
    patch_usage
    exit 1
  fi
  git checkout -qb "patch/${1}" release
}

patch_usage() {
  # print out the usage instructions for git auto patch
  # globals:
  #   none
  # arguments:
  #   none
  # returns:
  #   none
  echo "usage: git auto patch <command> <arg>"
  echo ""
  echo "where available options for <command> are:"
  echo "  finish:  merge patch branch named <arg> into master, delete it, and"
  echo "           create a new minor release"
  echo "  publish: push patch branch named <arg> to origin"
  echo "  start:   create new patch branch named <arg>"
  echo ""
  echo "for more command details run 'git auto <command> help'"
}
